---
import Layout from '../components/Layout.astro';
import GameTimer from '../components/GameTimer.astro';
import PlayerList from '../components/PlayerList.astro';
---

<Layout title="Obviously - Game" showSmallLogo={true}>
    <div class="screen active">
        <GameTimer />
        <div class="game-area">
            <div id="public-words-container" class="public-words">
                <!-- Public words will be displayed here -->
            </div>
            
            <PlayerList containerId="game-players-container" title="Players in Game" showGameStatus={true} />
        </div>
        <button id="leave-game-btn">Leave Game</button>
    </div>
</Layout>

<script>
import type { Room } from '../lib/room';

    // Get base URL from Astro config
    const BASE_URL = import.meta.env.BASE_URL;

    let gameTimer: NodeJS.Timeout | null = null;

    document.addEventListener('DOMContentLoaded', async () => {
        // Get room code from URL parameters
        const urlParams = new URLSearchParams(window.location.search);
        const roomCode = urlParams.get('code');
        
        if (!roomCode) {
            alert('No room code provided');
            window.location.href = BASE_URL;
            return;
        }
        
        // Get current player from localStorage
        const currentPlayerStr = localStorage.getItem('currentPlayer');
        if (!currentPlayerStr) {
            alert('No player data found');
            window.location.href = BASE_URL;
            return;
        }
        
        const currentPlayer = JSON.parse(currentPlayerStr);
        
        // Import Firebase singleton
        const { getDatabase, firebase } = await import('../lib/firebase');
        const database = getDatabase();
        
        // Wait for room to be in 'playing' status with publicWords loaded
        let gameInitialized = false;
        database.ref(`rooms/${roomCode}`).on('value', (snapshot) => {
            const roomData: Room = snapshot.val();
            
            if (!roomData) {
                alert('Room not found');
                window.location.href = BASE_URL;
                return;
            }
            
            // Wait until status is 'playing' AND publicWords exist
            if (roomData.status === 'playing' && roomData.publicWords && !gameInitialized) {
                gameInitialized = true;
                console.log('Game data loaded, starting game screen...');
                // Initialize game UI
                startGameScreen(roomData);
            } else if (roomData.status !== 'playing' && !gameInitialized) {
                // Not playing yet, keep waiting
                console.log('Waiting for game to start...');
            }
        });
        
        // Function to update game players list with their words
        function updateGamePlayersList(players: any, playerWords: any, publicWordChoices: any = {}) {
            const container = document.getElementById('game-players-container');
            if (!container || !players) return;
            
            container.innerHTML = '';
            
            const playerIds = Object.keys(players);
            const allSubmitted = playerIds.every(id => publicWordChoices[id]);
            
            Object.values(players).forEach((player: any) => {
                const playerDiv = document.createElement('div');
                playerDiv.className = 'player';
                
                const words = playerWords[player.id] || [];
                const wordsText = words.map((w: any) => w.text).join(', ');
                
                const hasSubmitted = publicWordChoices[player.id];
                // Show checkmark only if submitted AND not everyone has submitted yet
                const statusMark = hasSubmitted && !allSubmitted ? ' ✓' : '';
                
                playerDiv.innerHTML = `
                    <span class="player-name">${player.name}${statusMark}</span>
                    <span class="player-words">${wordsText}</span>
                `;
                container.appendChild(playerDiv);
            });
        }
        
        // Track selected public word
        let selectedPublicWord: any = null;
        let hasSubmittedChoice = false;
        
        // Function to display public words (clickable)
        function displayPublicWords(publicWords: any[]) {
            const container = document.getElementById('public-words-container');
            if (!container) return;
            
            // Reset the container with fresh HTML
            container.innerHTML = '<h3>Choose One Public Word</h3><div id="public-words-list"></div><button id="submit-choice-btn" disabled>Submit Choice</button>';
            
            const wordsList = document.getElementById('public-words-list');
            if (!wordsList) return;
            
            // Reset selection state (defensive - should already be reset)
            selectedPublicWord = null;
            
            publicWords.forEach((word: any, index: number) => {
                const wordDiv = document.createElement('div');
                wordDiv.className = 'word-item clickable';
                wordDiv.textContent = word.text;
                wordDiv.dataset.index = String(index);
                
                wordDiv.addEventListener('click', () => {
                    if (hasSubmittedChoice) return;
                    
                    // Deselect all
                    wordsList.querySelectorAll('.word-item').forEach(w => w.classList.remove('selected'));
                    
                    // Select this one
                    wordDiv.classList.add('selected');
                    selectedPublicWord = word;
                    
                    // Enable submit button
                    const submitBtn = document.getElementById('submit-choice-btn') as HTMLButtonElement;
                    if (submitBtn) {
                        submitBtn.disabled = false;
                        submitBtn.textContent = 'Submit Choice'; // Reset text too
                    }
                });
                
                wordsList.appendChild(wordDiv);
            });
            
            // Submit choice button handler (using 'once' option to prevent duplicate handlers)
            const submitBtn = document.getElementById('submit-choice-btn');
            if (submitBtn) {
                submitBtn.addEventListener('click', async () => {
                    if (!selectedPublicWord || hasSubmittedChoice) return;
                    
                    try {
                        await database.ref(`rooms/${roomCode}/publicWordChoices/${currentPlayer.id}`).set(selectedPublicWord);
                        hasSubmittedChoice = true;
                        
                        const btn = document.getElementById('submit-choice-btn') as HTMLButtonElement;
                        if (btn) {
                            btn.disabled = true;
                            btn.textContent = 'Choice Submitted ✓';
                        }
                        
                        // Disable further clicks
                        document.querySelectorAll('.word-item.clickable').forEach(w => {
                            (w as HTMLElement).style.pointerEvents = 'none';
                            (w as HTMLElement).style.opacity = '0.6';
                        });
                        
                    } catch (error) {
                        console.error('Error submitting choice:', error);
                        alert('Failed to submit choice');
                    }
                }, { once: true }); // Prevent duplicate event handlers
            }
        }
        
        // Function to start the game timer
        function startServerBasedTimer(startTime: number, duration: number) {
            const timerElement = document.getElementById('game-timer');
            
            const updateTimer = () => {
                const now = Date.now();
                const elapsed = Math.floor((now - startTime) / 1000);
                const timeLeft = Math.max(0, duration - elapsed);
                
                const minutes = Math.floor(timeLeft / 60);
                const seconds = timeLeft % 60;
                
                if (timerElement) {
                    timerElement.textContent = `Time: ${minutes}:${seconds.toString().padStart(2, '0')}`;
                }
                
                if (timeLeft <= 0) {
                    if (gameTimer) {
                        clearInterval(gameTimer);
                        gameTimer = null;
                    }
                    endGame();
                    return;
                }
            };
            
            // Clear any existing timer
            if (gameTimer) {
                clearInterval(gameTimer);
            }
            
            // Update immediately
            updateTimer();
            
            // Start the interval
            gameTimer = setInterval(updateTimer, 1000);
        }
        
        // Function to start game screen
        function startGameScreen(roomData: Room) {
            // Clean up any existing timer first
            if (gameTimer) {
                clearInterval(gameTimer);
                gameTimer = null;
            }
            
            // Display public words
            displayPublicWords(roomData.publicWords || []);
            
            // Update players list with their assigned words
            updateGamePlayersList(roomData.players, roomData.playerWords || {}, roomData.publicWordChoices || {});
            
            // Track if we've already revealed
            let hasRevealed = false;
            
            // Listen for public word choice updates
            database.ref(`rooms/${roomCode}/publicWordChoices`).on('value', async (snapshot) => {
                const choices = snapshot.val() || {};
                updateGamePlayersList(roomData.players, roomData.playerWords || {}, choices);
                
                // Check if all players have submitted
                const playerIds = Object.keys(roomData.players);
                const allSubmitted = playerIds.every(id => choices[id]);
                
                if (allSubmitted && !hasRevealed) {
                    hasRevealed = true;
                    // Reveal choices and calculate score
                    await revealChoices(roomCode, roomData.players, choices);
                }
            });
            
            // Listen for reveal state changes
            database.ref(`rooms/${roomCode}/choicesRevealed`).on('value', (snapshot) => {
                const revealed = snapshot.val();
                if (revealed) {
                    // Refresh room data to get updated points/fouls
                    database.ref(`rooms/${roomCode}`).once('value', (roomSnapshot) => {
                        const updatedRoom = roomSnapshot.val();
                        displayReveal(updatedRoom);
                    });
                } else if (revealed === false) {
                    // Round reset - reinitialize without reload to avoid flicker
                    hasRevealed = false;
                    database.ref(`rooms/${roomCode}`).once('value', (roomSnapshot) => {
                        const updatedRoom = roomSnapshot.val();
                        if (updatedRoom && updatedRoom.status === 'playing') {
                            // Clear submit state and display new round
                            hasSubmittedChoice = false;
                            selectedPublicWord = null;
                            displayPublicWords(updatedRoom.publicWords || []);
                            updateGamePlayersList(updatedRoom.players, updatedRoom.playerWords || {}, updatedRoom.publicWordChoices || {});
                            
                            // Restart timer with new start time
                            if (gameTimer) {
                                clearInterval(gameTimer);
                                gameTimer = null;
                            }
                            startServerBasedTimer(updatedRoom.startTime || Date.now(), updatedRoom.duration || 180);
                        }
                    });
                }
            });
            
            // Start timer
            const startTime = roomData.startTime || Date.now();
            startServerBasedTimer(startTime, roomData.duration || 180);
        }
        
        // Function to reveal choices and calculate score
        async function revealChoices(roomCode: string, players: any, choices: any) {
            try {
                // Count how many times each word was chosen
                const wordCounts: { [wordText: string]: string[] } = {}; // word -> playerIds[]
                
                Object.entries(choices).forEach(([playerId, word]: [string, any]) => {
                    if (!wordCounts[word.text]) {
                        wordCounts[word.text] = [];
                    }
                    wordCounts[word.text].push(playerId);
                });
                
                // Check if all words are unique
                const duplicates = Object.entries(wordCounts).filter(([_, playerIds]) => playerIds.length > 1);
                
                const updates: any = {
                    choicesRevealed: true
                };
                
                if (duplicates.length === 0) {
                    // All unique! Award a point
                    const currentPoints = (await database.ref(`rooms/${roomCode}/points`).once('value')).val() || 0;
                    updates.points = currentPoints + 1;
                } else {
                    // Duplicates found! Award a foul
                    const currentFouls = (await database.ref(`rooms/${roomCode}/fouls`).once('value')).val() || 0;
                    updates.fouls = currentFouls + 1;
                }
                
                await database.ref(`rooms/${roomCode}`).update(updates);
                
            } catch (error) {
                console.error('Error revealing choices:', error);
            }
        }
        
        // Function to display the reveal
        function displayReveal(roomData: any) {
            const container = document.getElementById('public-words-container');
            if (!container) return;
            
            // Count word occurrences
            const wordCounts: { [wordText: string]: { playerNames: string[], playerIds: string[], count: number } } = {};
            
            Object.entries(roomData.publicWordChoices || {}).forEach(([playerId, word]: [string, any]) => {
                if (!wordCounts[word.text]) {
                    wordCounts[word.text] = { playerNames: [], playerIds: [], count: 0 };
                }
                const player = roomData.players[playerId];
                wordCounts[word.text].playerNames.push(player.name);
                wordCounts[word.text].playerIds.push(playerId);
                wordCounts[word.text].count++;
            });
            
            const hasDuplicates = Object.values(wordCounts).some(wc => wc.count > 1);
            
            // Find which players failed (chose duplicates)
            const failedPlayerIds = new Set<string>();
            Object.values(wordCounts).forEach(data => {
                if (data.count > 1) {
                    data.playerIds.forEach(id => failedPlayerIds.add(id));
                }
            });
            
            const currentPlayerFailed = failedPlayerIds.has(currentPlayer.id);
            
            container.innerHTML = `
                <h3>Choices Revealed!</h3>
                <div class="score-display">
                    <div class="score-item ${hasDuplicates ? '' : 'success'}">
                        Points: ${roomData.points || 0}
                    </div>
                    <div class="score-item ${hasDuplicates ? 'error' : ''}">
                        Fouls: ${roomData.fouls || 0}
                    </div>
                </div>
                <div id="revealed-choices"></div>
                ${currentPlayerFailed ? '<div id="word-replacement-container"></div>' : ''}
                ${currentPlayer.isHost ? '<button id="next-round-btn" style="margin-top: 20px;">Next Round</button>' : '<p style="margin-top: 20px;">Waiting for host to start next round...</p>'}
            `;
            
            const choicesContainer = document.getElementById('revealed-choices');
            if (!choicesContainer) return;
            
            Object.entries(wordCounts).forEach(([wordText, data]) => {
                const isDuplicate = data.count > 1;
                const wordDiv = document.createElement('div');
                wordDiv.className = `revealed-word ${isDuplicate ? 'duplicate' : ''}`;
                wordDiv.innerHTML = `
                    <span class="word-text">${wordText}</span>
                    <span class="word-choosers">${data.playerNames.join(', ')}</span>
                `;
                choicesContainer.appendChild(wordDiv);
            });
            
            // Show word replacement UI for failed players
            if (currentPlayerFailed) {
                showWordReplacementUI(roomData);
            }
            
            // Attach next round handler for host
            if (currentPlayer.isHost) {
                const nextRoundBtn = document.getElementById('next-round-btn');
                nextRoundBtn?.addEventListener('click', () => startNextRound(roomCode, roomData));
            }
        }
        
        // Function to show word replacement UI for failed players
        function showWordReplacementUI(roomData: any) {
            const container = document.getElementById('word-replacement-container');
            if (!container) return;
            
            const myWords = roomData.playerWords?.[currentPlayer.id] || [];
            
            container.innerHTML = `
                <h4>Choose a word to replace:</h4>
                <div id="my-words-list"></div>
            `;
            
            const wordsList = document.getElementById('my-words-list');
            if (!wordsList) return;
            
            myWords.forEach((word: any, index: number) => {
                const wordDiv = document.createElement('div');
                wordDiv.className = 'word-item clickable replacement-word';
                wordDiv.textContent = word.text;
                wordDiv.dataset.index = index.toString();
                
                wordDiv.addEventListener('click', async () => {
                    // Mark for replacement
                    document.querySelectorAll('.replacement-word').forEach(w => w.classList.remove('selected'));
                    wordDiv.classList.add('selected');
                    
                    // Store replacement choice
                    await database.ref(`rooms/${roomCode}/replacements/${currentPlayer.id}`).set({
                        wordIndex: index,
                        ready: true
                    });
                });
                
                wordsList.appendChild(wordDiv);
            });
        }
        
        // Function to start next round (host only)
        async function startNextRound(roomCode: string, roomData: any) {
            try {
                const { pickRandomWords } = await import('../lib/words');
                
                // Get replacement info
                const replacementsSnapshot = await database.ref(`rooms/${roomCode}/replacements`).once('value');
                const replacements = replacementsSnapshot.val() || {};
                
                const playerIds = Object.keys(roomData.players);
                const playerCount = playerIds.length;
                
                // Count how many players need replacements
                const failedPlayers = Object.keys(replacements).filter(id => replacements[id]);
                const replacementCount = failedPlayers.length;
                
                // Calculate words needed: replacements + public words
                const publicWordCount = playerCount + 1;
                const totalWordsNeeded = replacementCount + publicWordCount;
                const selectedWords = pickRandomWords(totalWordsNeeded);
                
                // Update player words (replace failed players' words)
                const updatedPlayerWords: any = { ...roomData.playerWords };
                let wordIndex = 0;
                
                for (const playerId of playerIds) {
                    if (replacements[playerId]) {
                        // This player failed - replace their chosen word
                        const replaceIndex = replacements[playerId].wordIndex;
                        const currentWords = [...updatedPlayerWords[playerId]];
                        currentWords[replaceIndex] = selectedWords[wordIndex++];
                        updatedPlayerWords[playerId] = currentWords;
                    }
                }
                
                // Remaining words are new public words (always playerCount + 1)
                const publicWords = selectedWords.slice(wordIndex);
                
                // Update room for next round
                await database.ref(`rooms/${roomCode}`).update({
                    publicWords: publicWords,
                    playerWords: updatedPlayerWords,
                    publicWordChoices: null, // Clear previous choices
                    choicesRevealed: false,
                    replacements: null, // Clear replacements
                    startTime: Date.now()
                });
                
            } catch (error) {
                console.error('Error starting next round:', error);
                alert('Failed to start next round');
            }
        }
        
        // Function to end game
        function endGame() {
            alert("Time's up! Game ended.");
            // Could redirect to results screen or back to lobby
        }
        
        // Leave game button handler
        const leaveGameBtn = document.getElementById('leave-game-btn');
        leaveGameBtn?.addEventListener('click', async () => {
            try {
                await database.ref(`rooms/${roomCode}/players/${currentPlayer.id}`).remove();
                
                // Clean up listeners
                database.ref(`rooms/${roomCode}`).off();
                database.ref(`rooms/${roomCode}/publicWordChoices`).off();
                
                // Clean up timer
                if (gameTimer) {
                    clearInterval(gameTimer);
                    gameTimer = null;
                }
                
                // Clear localStorage
                localStorage.removeItem('currentRoom');
                localStorage.removeItem('currentPlayer');
                
                window.location.href = BASE_URL;
                
            } catch (error) {
                console.error('Error leaving room:', error);
                alert('Failed to leave room');
            }
        });
    });
</script>